/\*\*
#Plan:

1. **Understand the problem:**

   - Clearly state what the function is supposed to return.
   - Identify the type of input and output (e.g., array, number, string).
   - Identify any constraints or conditions (e.g., sorted array, non-decreasing order).

2. **Break down input data & transformations:**

   - Describe the input data and its structure (e.g., an array of integers, string, etc.).
   - Identify the required transformations on the input (e.g., sorting, filtering, etc.).

3. **Edge cases:**

   - List all edge cases to consider, such as:
     - Empty input.
     - Single-element input.
     - Special values (e.g., null, undefined).
     - Cases that could affect performance or logic (e.g., all elements the same, all unique, etc.).

4. **Data structures:**

   - Specify the main data structure(s) you'll use (e.g., array, object, map, set).
   - Explain why these structures are appropriate for this problem.

5. **Approach:**

   - **Brute-force approach:** (if applicable, describe a simple but inefficient solution).
   - **Optimized approach:** Describe the more efficient solution (e.g., Two Pointers, sliding window, divide and conquer, dynamic programming, etc.).
   - Consider the time complexity of each approach and choose the optimal one.

6. **Time & Space Complexity:**
   - **Time complexity:** Analyze the time complexity of your solution.
   - **Space complexity:** Analyze the space complexity (if extra space is used).
     \*/

// Function
function solveProblem(input) {
// Step 1: Parse or transform input if needed

// Step 2: Set up data structures

// Step 3: Apply main logic (loop, condition, etc.)

// Step 4: Return result
}

/\*

# Custom Test Cases

\*/
console.log(solveProblem(...)) // Expected output
